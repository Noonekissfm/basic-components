import React, { FC } from 'react';

import './style.css'

interface IProps {
    children: any;
    width: number;
    height: number;
}

export const Rail: FC<IProps> = ({children, width, height}) => {

    return (
        <div className='rail__container' style={{width: `${width}%`,  height: `${height}px`}}>
            {children}
        </div>
    )
};




/**Это должна быть универсальная карусель, принимающая разные элементы , т. е. апи карусельки долно быть таким, чтобы в нее можно было прокинуть что угодно в виде массива и оно бы скролилось 
Также надо иметь в виду, что компонент может использоваться для бесконечных рейлов, поэтому  карусель должна уметь трекать состояние, когда ее «почти» долистали. «Почти» тут в том смысле, что можем прокинуть ширину в пикселях или количество карточек, до которого нужно начать загрузку. 
Ну и стрелки еще у карусели должны быть. Если уперлись в край и листать дальше некуда, то стрелочку не рисовать.

Это актуально не только для ui-kit. Обычно в разработке приветствуется модульный подход, когда компонент можно переиспользовать.
Я бы сделала два компонента. Первый - универсальная карусель Carousel, второй - компонент, использующий карусель, Rail. Для первой отрисовки карусели прокинула бы массив дивчиков - это те элементы, которые будут внутри карусели. В продуктовой разработке это могли бы быть карточки. Причем карточки могут бы быть разной ширины. При достижении конца карусели компонент Carousel должен вызывать колбек. Колбек этот должен быть внутри Rail. 
То есть общая идея такая - компонент Carousel ничего не знает про то, что он будет скролить, а вся подготовка данных должна быть там, где он используется. */

/**
 * 1. Карусель должна принимать любые элементы в виде массива и выводить их на страницу.
 * 2. Карусель может быть бесконечной, то есть должен быть функционал отслеживающий скролл карусели, и в случае, если карусель доскролили, 
 * должен срабатывать колбек, который загружает дополнительные данные для неё
 * 3. Должны быть стрелки, которые также отслеживают состояние и убираются, когда нет возможности прокрутить карусель в конкретную сторону.
 */